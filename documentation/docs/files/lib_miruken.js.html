<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>lib\miruken.js - miruken</title>
    <link rel="stylesheet" href="">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="../assets/css/custom.css">
    <link rel="stylesheet" href="../assets/vendor/bootstrap/css/bootstrap.css">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
</head>
<body class="yui3-skin-sam">
<div class="navbar navbar-fixed-top">
    <div class="navbar-inner">
        <h1 class="brand" style="padding: 10px 16px 10px; height: 20px; line-height: 20px; margin-left: 0;">
	    <img alt="miruken" src="../assets/css/logo.png" style="max-height: 65%;" title="miruken">
            miruken
        </h1>
	<div class="nav">
            <li class="divider-vertical"></li>
            <li>
                <p class="navbar-text">
                    API Docs for Version: <b>0.1.0</b>
                </p>
            </li>
        </div>
        <form class="navbar-form pull-right" style="line-height: 40px; height: 40px;">
            <input style="margin-top: 0;" type="text" class="search-query" placeholder="Search for classes/modules..." data-obj='["classes/miruken.$inferProperties", "classes/miruken.$inhertStatic", "classes/miruken.$interceptMethods", "classes/miruken.$properties", "classes/miruken.$proxyProtocol", "classes/miruken.ArrayManager", "classes/miruken.callback.$callbacks", "classes/miruken.callback._Node", "classes/miruken.callback.AcceptingCallbackHandler", "classes/miruken.callback.CallbackHandler", "classes/miruken.callback.CallbackHandlerAspect", "classes/miruken.callback.CallbackHandlerDecorator", "classes/miruken.callback.CallbackHandlerFilter", "classes/miruken.callback.CascadeCallbackHandler", "classes/miruken.callback.CompositeCallbackHandler", "classes/miruken.callback.ConditionalCallbackHandler", "classes/miruken.callback.Deferred", "classes/miruken.callback.HandleMethod", "classes/miruken.callback.InvocationDelegate", "classes/miruken.callback.InvocationOptionsHandler", "classes/miruken.callback.InvocationSemantics", "classes/miruken.callback.Lookup", "classes/miruken.callback.MethodCallbackHandler", "classes/miruken.callback.ProvidingCallbackHandler", "classes/miruken.callback.Reentrant", "classes/miruken.callback.ReentrantDecorator", "classes/miruken.callback.RejectedError", "classes/miruken.callback.Resolution", "classes/miruken.ClassMeta", "classes/miruken.context.{$contextual}
Metamacro to implement Contextual protocol.", "classes/miruken.context.{ContextualHelper}", "classes/miruken.context.{Contextual}", "classes/miruken.context.{Context}", "classes/miruken.Delegate", "classes/miruken.Disposing", "classes/miruken.DisposingMixin", "classes/miruken.Enum", "classes/miruken.error.{ErrorCallbackHandler}", "classes/miruken.graph.Traversal", "classes/miruken.graph.Traversing", "classes/miruken.graph.TraversingMixin", "classes/miruken.IndexedList", "classes/miruken.InstanceMeta", "classes/miruken.Interceptor", "classes/miruken.InterceptorSelector", "classes/miruken.Invoking", "classes/miruken.ioc..{BasedOnBuilder}", "classes/miruken.ioc..{FromBuilder}", "classes/miruken.ioc..{FromPackageBuilder}", "classes/miruken.ioc..{Installer}", "classes/miruken.ioc..{KeyBuilder}", "classes/miruken.ioc.ComponentBuilder", "classes/miruken.ioc.ComponentModel", "classes/miruken.ioc.ComponentPolicy", "classes/miruken.ioc.Container", "classes/miruken.ioc.ContextualLifestyle", "classes/miruken.ioc.DependencyInspector", "classes/miruken.ioc.DependencyManager", "classes/miruken.ioc.DependencyModel", "classes/miruken.ioc.DependencyResolution", "classes/miruken.ioc.DependencyResolutionError", "classes/miruken.ioc.InterceptorBuilder", "classes/miruken.ioc.IoContainer", "classes/miruken.ioc.Lifestyle", "classes/miruken.ioc.Registration", "classes/miruken.ioc.SingletonLifestyle", "classes/miruken.ioc.TransientLifestyle", "classes/miruken.ioc.ValidationError", "classes/miruken.MetaBase", "classes/miruken.MetaMacro", "classes/miruken.Miruken", "classes/miruken.Modifier", "classes/miruken.mvc.{Controller}", "classes/miruken.mvc.{Model}", "classes/miruken.ng.Directive", "classes/miruken.ng.Runner", "classes/miruken.ng.UseModelValidation", "classes/miruken.ObjectDelegate", "classes/miruken.Parenting", "classes/miruken.Protocol", "classes/miruken.ProxyBuilder", "classes/miruken.Starting", "classes/miruken.Startup", "classes/miruken.StrictProtocol", "classes/miruken.validate.{$validateThat}
Metamacro to validate instances.", "classes/miruken.validate.{ValidateJsCallbackHandler}", "classes/miruken.validate.{ValidationCallbackHandler}", "classes/miruken.validate.{ValidationRegistry}", "classes/miruken.validate.{ValidationResult}", "classes/miruken.validate.{Validation}", "modules/callback", "modules/ioc", "modules/miruken"]'>
        </form>
    </div>
</div>
<div class="container">
    <div class="row">
        <div class="span3">
	    <div>
	        <h3>APIs</h3>
	        <div id="sidebar">
	            <ul id="main-nav" class="nav nav-tabs" style="margin-bottom:0;">
	                <li class="active"><a href="#classes" data-toggle="tab">Classes</a></li>
	                <li><a href="#modules" data-toggle="tab">Modules</a></li>
	            </ul>
	    
	            <div id="api-tabview-filter">
	                <input type="search" placeholder="Type to filter APIs">
	            </div>
	    
	            <div class="tab-content" style="border: 1px solid #DDD; border-top:0;">
	                <div class="tab-pane active" id="classes">
	                    <ul id="api-classes" class="nav nav-list">
	                            <li><a href="../classes/miruken.$inferProperties.html">miruken.$inferProperties</a></li>
	                            <li><a href="../classes/miruken.$inhertStatic.html">miruken.$inhertStatic</a></li>
	                            <li><a href="../classes/miruken.$interceptMethods.html">miruken.$interceptMethods</a></li>
	                            <li><a href="../classes/miruken.$properties.html">miruken.$properties</a></li>
	                            <li><a href="../classes/miruken.$proxyProtocol.html">miruken.$proxyProtocol</a></li>
	                            <li><a href="../classes/miruken.ArrayManager.html">miruken.ArrayManager</a></li>
	                            <li><a href="../classes/miruken.callback.$callbacks.html">miruken.callback.$callbacks</a></li>
	                            <li><a href="../classes/miruken.callback._Node.html">miruken.callback._Node</a></li>
	                            <li><a href="../classes/miruken.callback.AcceptingCallbackHandler.html">miruken.callback.AcceptingCallbackHandler</a></li>
	                            <li><a href="../classes/miruken.callback.CallbackHandler.html">miruken.callback.CallbackHandler</a></li>
	                            <li><a href="../classes/miruken.callback.CallbackHandlerAspect.html">miruken.callback.CallbackHandlerAspect</a></li>
	                            <li><a href="../classes/miruken.callback.CallbackHandlerDecorator.html">miruken.callback.CallbackHandlerDecorator</a></li>
	                            <li><a href="../classes/miruken.callback.CallbackHandlerFilter.html">miruken.callback.CallbackHandlerFilter</a></li>
	                            <li><a href="../classes/miruken.callback.CascadeCallbackHandler.html">miruken.callback.CascadeCallbackHandler</a></li>
	                            <li><a href="../classes/miruken.callback.CompositeCallbackHandler.html">miruken.callback.CompositeCallbackHandler</a></li>
	                            <li><a href="../classes/miruken.callback.ConditionalCallbackHandler.html">miruken.callback.ConditionalCallbackHandler</a></li>
	                            <li><a href="../classes/miruken.callback.Deferred.html">miruken.callback.Deferred</a></li>
	                            <li><a href="../classes/miruken.callback.HandleMethod.html">miruken.callback.HandleMethod</a></li>
	                            <li><a href="../classes/miruken.callback.InvocationDelegate.html">miruken.callback.InvocationDelegate</a></li>
	                            <li><a href="../classes/miruken.callback.InvocationOptionsHandler.html">miruken.callback.InvocationOptionsHandler</a></li>
	                            <li><a href="../classes/miruken.callback.InvocationSemantics.html">miruken.callback.InvocationSemantics</a></li>
	                            <li><a href="../classes/miruken.callback.Lookup.html">miruken.callback.Lookup</a></li>
	                            <li><a href="../classes/miruken.callback.MethodCallbackHandler.html">miruken.callback.MethodCallbackHandler</a></li>
	                            <li><a href="../classes/miruken.callback.ProvidingCallbackHandler.html">miruken.callback.ProvidingCallbackHandler</a></li>
	                            <li><a href="../classes/miruken.callback.Reentrant.html">miruken.callback.Reentrant</a></li>
	                            <li><a href="../classes/miruken.callback.ReentrantDecorator.html">miruken.callback.ReentrantDecorator</a></li>
	                            <li><a href="../classes/miruken.callback.RejectedError.html">miruken.callback.RejectedError</a></li>
	                            <li><a href="../classes/miruken.callback.Resolution.html">miruken.callback.Resolution</a></li>
	                            <li><a href="../classes/miruken.ClassMeta.html">miruken.ClassMeta</a></li>
	                            <li><a href="../classes/miruken.context.{$contextual}
	    Metamacro to implement Contextual protocol..html">miruken.context.{$contextual}
	    Metamacro to implement Contextual protocol.</a></li>
	                            <li><a href="../classes/miruken.context.{ContextualHelper}.html">miruken.context.{ContextualHelper}</a></li>
	                            <li><a href="../classes/miruken.context.{Contextual}.html">miruken.context.{Contextual}</a></li>
	                            <li><a href="../classes/miruken.context.{Context}.html">miruken.context.{Context}</a></li>
	                            <li><a href="../classes/miruken.Delegate.html">miruken.Delegate</a></li>
	                            <li><a href="../classes/miruken.Disposing.html">miruken.Disposing</a></li>
	                            <li><a href="../classes/miruken.DisposingMixin.html">miruken.DisposingMixin</a></li>
	                            <li><a href="../classes/miruken.Enum.html">miruken.Enum</a></li>
	                            <li><a href="../classes/miruken.error.{ErrorCallbackHandler}.html">miruken.error.{ErrorCallbackHandler}</a></li>
	                            <li><a href="../classes/miruken.graph.Traversal.html">miruken.graph.Traversal</a></li>
	                            <li><a href="../classes/miruken.graph.Traversing.html">miruken.graph.Traversing</a></li>
	                            <li><a href="../classes/miruken.graph.TraversingMixin.html">miruken.graph.TraversingMixin</a></li>
	                            <li><a href="../classes/miruken.IndexedList.html">miruken.IndexedList</a></li>
	                            <li><a href="../classes/miruken.InstanceMeta.html">miruken.InstanceMeta</a></li>
	                            <li><a href="../classes/miruken.Interceptor.html">miruken.Interceptor</a></li>
	                            <li><a href="../classes/miruken.InterceptorSelector.html">miruken.InterceptorSelector</a></li>
	                            <li><a href="../classes/miruken.Invoking.html">miruken.Invoking</a></li>
	                            <li><a href="../classes/miruken.ioc..{BasedOnBuilder}.html">miruken.ioc..{BasedOnBuilder}</a></li>
	                            <li><a href="../classes/miruken.ioc..{FromBuilder}.html">miruken.ioc..{FromBuilder}</a></li>
	                            <li><a href="../classes/miruken.ioc..{FromPackageBuilder}.html">miruken.ioc..{FromPackageBuilder}</a></li>
	                            <li><a href="../classes/miruken.ioc..{Installer}.html">miruken.ioc..{Installer}</a></li>
	                            <li><a href="../classes/miruken.ioc..{KeyBuilder}.html">miruken.ioc..{KeyBuilder}</a></li>
	                            <li><a href="../classes/miruken.ioc.ComponentBuilder.html">miruken.ioc.ComponentBuilder</a></li>
	                            <li><a href="../classes/miruken.ioc.ComponentModel.html">miruken.ioc.ComponentModel</a></li>
	                            <li><a href="../classes/miruken.ioc.ComponentPolicy.html">miruken.ioc.ComponentPolicy</a></li>
	                            <li><a href="../classes/miruken.ioc.Container.html">miruken.ioc.Container</a></li>
	                            <li><a href="../classes/miruken.ioc.ContextualLifestyle.html">miruken.ioc.ContextualLifestyle</a></li>
	                            <li><a href="../classes/miruken.ioc.DependencyInspector.html">miruken.ioc.DependencyInspector</a></li>
	                            <li><a href="../classes/miruken.ioc.DependencyManager.html">miruken.ioc.DependencyManager</a></li>
	                            <li><a href="../classes/miruken.ioc.DependencyModel.html">miruken.ioc.DependencyModel</a></li>
	                            <li><a href="../classes/miruken.ioc.DependencyResolution.html">miruken.ioc.DependencyResolution</a></li>
	                            <li><a href="../classes/miruken.ioc.DependencyResolutionError.html">miruken.ioc.DependencyResolutionError</a></li>
	                            <li><a href="../classes/miruken.ioc.InterceptorBuilder.html">miruken.ioc.InterceptorBuilder</a></li>
	                            <li><a href="../classes/miruken.ioc.IoContainer.html">miruken.ioc.IoContainer</a></li>
	                            <li><a href="../classes/miruken.ioc.Lifestyle.html">miruken.ioc.Lifestyle</a></li>
	                            <li><a href="../classes/miruken.ioc.Registration.html">miruken.ioc.Registration</a></li>
	                            <li><a href="../classes/miruken.ioc.SingletonLifestyle.html">miruken.ioc.SingletonLifestyle</a></li>
	                            <li><a href="../classes/miruken.ioc.TransientLifestyle.html">miruken.ioc.TransientLifestyle</a></li>
	                            <li><a href="../classes/miruken.ioc.ValidationError.html">miruken.ioc.ValidationError</a></li>
	                            <li><a href="../classes/miruken.MetaBase.html">miruken.MetaBase</a></li>
	                            <li><a href="../classes/miruken.MetaMacro.html">miruken.MetaMacro</a></li>
	                            <li><a href="../classes/miruken.Miruken.html">miruken.Miruken</a></li>
	                            <li><a href="../classes/miruken.Modifier.html">miruken.Modifier</a></li>
	                            <li><a href="../classes/miruken.mvc.{Controller}.html">miruken.mvc.{Controller}</a></li>
	                            <li><a href="../classes/miruken.mvc.{Model}.html">miruken.mvc.{Model}</a></li>
	                            <li><a href="../classes/miruken.ng.Directive.html">miruken.ng.Directive</a></li>
	                            <li><a href="../classes/miruken.ng.Runner.html">miruken.ng.Runner</a></li>
	                            <li><a href="../classes/miruken.ng.UseModelValidation.html">miruken.ng.UseModelValidation</a></li>
	                            <li><a href="../classes/miruken.ObjectDelegate.html">miruken.ObjectDelegate</a></li>
	                            <li><a href="../classes/miruken.Parenting.html">miruken.Parenting</a></li>
	                            <li><a href="../classes/miruken.Protocol.html">miruken.Protocol</a></li>
	                            <li><a href="../classes/miruken.ProxyBuilder.html">miruken.ProxyBuilder</a></li>
	                            <li><a href="../classes/miruken.Starting.html">miruken.Starting</a></li>
	                            <li><a href="../classes/miruken.Startup.html">miruken.Startup</a></li>
	                            <li><a href="../classes/miruken.StrictProtocol.html">miruken.StrictProtocol</a></li>
	                            <li><a href="../classes/miruken.validate.{$validateThat}
	    Metamacro to validate instances..html">miruken.validate.{$validateThat}
	    Metamacro to validate instances.</a></li>
	                            <li><a href="../classes/miruken.validate.{ValidateJsCallbackHandler}.html">miruken.validate.{ValidateJsCallbackHandler}</a></li>
	                            <li><a href="../classes/miruken.validate.{ValidationCallbackHandler}.html">miruken.validate.{ValidationCallbackHandler}</a></li>
	                            <li><a href="../classes/miruken.validate.{ValidationRegistry}.html">miruken.validate.{ValidationRegistry}</a></li>
	                            <li><a href="../classes/miruken.validate.{ValidationResult}.html">miruken.validate.{ValidationResult}</a></li>
	                            <li><a href="../classes/miruken.validate.{Validation}.html">miruken.validate.{Validation}</a></li>
	                    </ul>
	                </div>
	    
	                <div class="tab-pane" id="modules">
	                    <ul id="api-modules" class="nav nav-list">
	                            <li><a href="../modules/callback.html">callback</a></li>
	                            <li><a href="../modules/ioc.html">ioc</a></li>
	                            <li><a href="../modules/miruken.html">miruken</a></li>
	                    </ul>
	                </div>
	            </div>
	        </div>
	    </div>
        </div>
        <div class="span9">
                <form id="options-form" class="form-inline pull-right">
                    Show:
                    <label for="api-show-inherited" class="checkbox">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected" class="checkbox">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private" class="checkbox">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated" class="checkbox">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </form>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <div class="page-header">
                            <h1>lib\miruken.js <small>File</small></h1>
                        </div>
                        
                        <div class="file">
                            <pre class="prettyprint linenums">
                        require(&#x27;./base2.js&#x27;);
                        
                        new function () { // closure
                        
                            /**
                             * Definition goes here
                             * @module miruken
                             * @namespace miruken
                             */
                            var miruken = new base2.Package(this, {
                                name:    &quot;miruken&quot;,
                                version: &quot;1.0&quot;,
                                exports: &quot;Enum,Variance,Protocol,StrictProtocol,Delegate,Miruken,MetaStep,MetaMacro,Disposing,DisposingMixin,Invoking,Parenting,Starting,Startup,Facet,Interceptor,InterceptorSelector,ProxyBuilder,Modifier,ArrayManager,IndexedList,$isProtocol,$isClass,$classOf,$ancestorOf,$isString,$isFunction,$isObject,$isPromise,$isNothing,$isSomething,$using,$lift,$debounce,$eq,$use,$copy,$lazy,$eval,$every,$child,$optional,$promise,$instant,$createModifier,$properties,$inferProperties,$inheritStatic&quot;
                            });
                        
                            eval(this.imports);
                        
                            var META = &#x27;$meta&#x27;;
                        
                            var $eq       = $createModifier(),
                                $use      = $createModifier(),
                                $copy     = $createModifier(),
                                $lazy     = $createModifier(),
                                $eval     = $createModifier(),
                                $every    = $createModifier(),
                                $child    = $createModifier(),
                                $optional = $createModifier(),
                                $promise  = $createModifier(),
                                $instant  = $createModifier();
                            
                            /**
                             * Represents an enumeration
                             * @class Enum
                             * @constructor
                             */
                            var Enum = Base.extend({
                                constructor: function() {
                                    throw new TypeError(&quot;Enums cannot be instantiated.&quot;);
                                }
                            }, {
                                coerce: function (choices) {
                                    var en     = this.extend(null, choices),
                                        names  = Object.freeze(Object.keys(choices)),
                                        values = Object.freeze(Array2.map(names, function (name) {
                                                return choices[name];
                                        }));
                                    Object.defineProperties(en, {
                                        names:  { value: names },
                                        values: { value: values }
                                    });
                                    return Object.freeze(en);
                                }
                            });
                        
                            /**
                             * Variance enum
                             * @property Variance
                             * @type Enum
                             */
                            var Variance = Enum({
                                Covariant:     1,  // out
                                Contravariant: 2,  // in
                                Invariant:     3   // exact
                                });
                        
                            /**
                             * Delegates stuff
                             * @class Delegate
                             * @extends Base
                             */
                            var Delegate = Base.extend({
                                /**
                                 * Delegates the property get on the protocol.
                                 * @method get
                                 * @param   {Protocol} protocol      - receiving protocol
                                 * @param   {string}   propertyName  - name of the property
                                 * @param   {boolean}  strict        - true if target must adopt protocol
                                 * @returns {Any}      the result of the proxied get.
                                 */
                                get: function (protocol, propertyName, strict) {},
                                /**
                                 * Delegates the property set on the protocol.
                                 * @method set
                                 * @param   {Protocol} protocol      - receiving protocol
                                 * @param   {string}   propertyName  - name of the property
                                 * @param   {Object}   propertyValue - value of the property
                                 * @param   {boolean}  strict        - true if target must adopt protocol
                                 */
                                set: function (protocol, propertyName, propertyValue, strict) {},
                                /**
                                 * Delegates the method invocation on the protocol.
                                 * @method invoke
                                 * @param   {Protocol} protocol    - receiving protocol
                                 * @param   {string}   methodName  - name of the method
                                 * @param   {Array}    args        - method arguments
                                 * @param   {boolean}  strict      - true if target must adopt protocol
                                 * @returns {Any}      the result of the proxied invocation.
                                 */
                                 invoke: function (protocol, methodName, args, strict) {}
                            });
                        
                            /**
                             * @class ObjectDelegate
                             * @constructor
                             * @extends Delegate
                             */
                            var ObjectDelegate = Delegate.extend({
                                constructor: function (object) {
                                    if ($isNothing(object)) {
                                        throw new TypeError(&quot;No object specified.&quot;);
                                    }
                                    Object.defineProperty(this, &#x27;object&#x27;, { value: object });
                                },
                                /**
                                 * Description goes here
                                 * @method get
                                 * @params {Protocol}    protocol        - definition
                                 * @params {string}      propertyName    - definition
                                 * @params {boolean}     strict          - definition
                                 * @return {Object}      object          - definition
                                 */
                                get: function (protocol, propertyName, strict) {
                                    var object = this.object;
                                    if (!strict || protocol.adoptedBy(object)) {
                                        return object[propertyName];
                                    }
                                },
                                /**
                                 * Description goes here
                                 * @method set
                                 * @params {Protocol}    protocol        - definition
                                 * @params {string}      propertyName    - definition
                                 * @params {string}      propertyValue   - definition
                                 * @params {boolean}     strict          - definition
                                 * @return {Object}      object          - definition
                                 */
                                set: function (protocol, propertyName, propertyValue, strict) {
                                    var object = this.object;
                                    if (!strict || protocol.adoptedBy(object)) {
                                        return object[propertyName] = propertyValue;
                                    }
                                },
                                /**
                                 * Description goes here
                                 * @method invoke
                                 * @params {Protocol}    protocol        - definition
                                 * @params {string}      methodName      - definition
                                 * @params {Array}       args            - definition
                                 * @params {boolean}     strict          - definition
                                 * @return {Method}      method          - definition
                                 */
                                invoke: function (protocol, methodName, args, strict) {
                                    var object = this.object,
                                        method = object[methodName];
                                    if (method &amp;&amp; (!strict || protocol.adoptedBy(object))) {
                                        return method.apply(object, args);
                                    }
                                }
                            });
                            
                            /**
                             * Description goes here
                             * @class Protocol
                             * @constructor
                             * @extends Base
                             */
                            var Protocol = Base.extend({
                                constructor: function (delegate, strict) {
                                    if ($isNothing(delegate)) {
                                        delegate = new Delegate;
                                    } else if ((delegate instanceof Delegate) === false) {
                                        if ($isFunction(delegate.toDelegate)) {
                                            delegate = delegate.toDelegate();
                                            if ((delegate instanceof Delegate) === false) {
                                                throw new TypeError(format(
                                                    &quot;Invalid delegate: %1 is not a Delegate nor does it have a &#x27;toDelegate&#x27; method that returned one.&quot;, delegate));
                                            }
                                        } else {
                                            delegate = new ObjectDelegate(delegate);
                                        }
                                    }
                                    Object.defineProperty(this, &#x27;delegate&#x27;, { value: delegate });
                                    Object.defineProperty(this, &#x27;strict&#x27;, { value: !!strict });
                                },
                                __get: function (propertyName) {
                                    return this.delegate.get(this.constructor, propertyName, this.strict);
                                },
                                __set: function (propertyName, propertyValue) {                
                                    return this.delegste.set(this.constructor, propertyName, propertyValue, this.strict);
                                },
                                __invoke: function (methodName, args) {
                                    return this.delegate.invoke(this.constructor, methodName, args, this.strict);
                                }
                            }, {
                                isProtocol: function (target) {
                                    return target &amp;&amp; (target.prototype instanceof Protocol);
                                },
                                conformsTo: False,
                                adoptedBy:  function (target) {
                                    return target &amp;&amp; $isFunction(target.conformsTo)
                                         ? target.conformsTo(this)
                                         : false;
                                },
                                coerce: function (object, strict) { return new this(object, strict); }
                            });
                        
                            /**
                             * MetaStep enum
                             * @property MetaStep
                             * @type Enum
                             */
                            var MetaStep = Enum({
                                Subclass:  1,
                                Implement: 2,
                                Extend:    3
                                });
                        
                            /**
                             * Description goes here
                             * @class MetaMacro
                             * @extends Base
                             */
                            var MetaMacro = Base.extend({
                                /**
                                 * Description goes here
                                 * @method apply
                                 * @param {Step}           step        - definition
                                 * @param {MetaData}       metadata    - definition
                                 * @param {Target}         target      - definition
                                 * @param {Definition}     definition  - definition
                                 */
                                apply: function (step, metadata, target, definition) {},
                                /**
                                 * Description goes here
                                 * @method protocolAdded
                                 * @param {MetaData}       metadata    - definition
                                 * @param {Protocol}       protocol    - definition
                                 */
                                protocolAdded: function (metadata, protocol) {},
                                shouldInherit: False,
                                isActive: False,
                            }, {
                                coerce: function () { return this.new.apply(this, arguments); }
                            });
                        
                            /**
                             * Description goes here
                             * @class MetaBase
                             * @constructor
                             * @extends MetaMacro
                             */
                            var MetaBase = MetaMacro.extend({
                                constructor: function(parent)  {
                                    var _protocols   = [],
                                        _descriptors;
                                    this.extend({
                                        /**
                                         * Description goes here
                                         * @method getParent
                                         * @return {Parent}     parent          - definition
                                         */
                                        getParent: function () { return parent; },
                                        /**
                                         * Description goes here
                                         * @method getProtocols
                                         * @return {Protocols}     protocols    - definition
                                         */
                                        getProtocols: function () { return _protocols.slice(0) },
                                        /**
                                         * Description goes here
                                         * @method getAllProtocols
                                         * @return {Array}     protocols        - definition
                                         */
                                        getAllProtocols: function () {
                                            var protocols = this.getProtocols(),
                                                inner     = protocols.slice(0);
                                            for (var i = 0; i &lt; inner.length; ++i) {
                                                var innerProtocols = inner[i].$meta.getAllProtocols();
                                                for (var ii = 0; ii &lt; innerProtocols.length; ++ii) {
                                                    var protocol = innerProtocols[ii];
                                                    if (protocols.indexOf(protocol) &lt; 0) {
                                                        protocols.push(protocol);
                                                    }
                                                } 
                                            }
                                            return protocols;
                                        },
                                        /**
                                         * Description goes here
                                         * @method addProtocol
                                         * @param  {Array}     protocols        - definition
                                         * @return {Array}     protocols        - definition
                                         */
                                        addProtocol: function (protocols) {
                                            if ($isNothing(protocols)) {
                                                return;
                                            }
                                            if (!(protocols instanceof Array)) {
                                                protocols = Array.prototype.slice.call(arguments);
                                            }
                                            for (var i = 0; i &lt; protocols.length; ++i) {
                                                var protocol = protocols[i];
                                                if ((protocol.prototype instanceof Protocol) 
                                                &amp;&amp;  (_protocols.indexOf(protocol) === -1)) {
                                                    _protocols.push(protocol);
                                                    this.protocolAdded(this, protocol);
                                                }
                                            }
                                        },
                                        protocolAdded: function (metadata, protocol) {
                                            if (parent) {
                                                parent.protocolAdded(metadata, protocol);
                                            }
                                        },
                                        /**
                                         * Description goes here
                                         * @method conformsTo
                                         * @params {Protocol}   protocol     - definition
                                         * @return {boolean}    bool         - definition
                                         */
                                        conformsTo: function (protocol) {
                                            if (!(protocol &amp;&amp; (protocol.prototype instanceof Protocol))) {
                                                return false;
                                            }
                                            for (var index = 0; index &lt; _protocols.length; ++index) {
                                                var proto = _protocols[index];
                                                if (protocol === proto || proto.conformsTo(protocol)) {
                                                    return true;
                                                }
                                            }
                                            return false;
                                        },
                                        apply: function _(step, metadata, target, definition) {
                                            if (parent) {
                                                parent.apply(step, metadata, target, definition);
                                            } else if ($properties) {
                                                (_.p || (_.p = new $properties)).apply(step, metadata, target, definition);
                                            }
                                        },
                                        /**
                                         * Description goes here
                                         * @method defineProperty
                                         * @param  {Object}     target      - definition
                                         * @param  {string}     name        - definition
                                         * @param  {Object}     spec        - definition
                                         * @param  {Object}     descriptor  - definition
                                         */
                                        defineProperty: function(target, name, spec, descriptor) {
                                            descriptor = extend({}, descriptor);
                                            Object.defineProperty(target, name, spec);
                                            this.addDescriptor(name, descriptor);
                                        },
                                        /**
                                         * Description goes here
                                         * @method getDescriptor
                                         * @param  {Filter}     filter      - definition
                                         * @return {Parent}     parent      - definition
                                         */
                                        getDescriptor: function (filter) {
                                            var descriptors;
                                            if ($isNothing(filter)) {
                                                if (parent) {
                                                    descriptors = parent.getDescriptor(filter);
                                                }
                                                if (_descriptors) {
                                                    descriptors = extend(descriptors || {}, _descriptors);
                                                }
                                            } else if ($isString(filter)) {
                                                return _descriptors[filter] || (parent &amp;&amp; parent.getDescriptor(filter));
                                            } else {
                                                if (parent) {
                                                    descriptors = parent.getDescriptor(filter);
                                                }
                                                for (var key in _descriptors) {
                                                    var descriptor = _descriptors[key];
                                                    if (this.matchDescriptor(descriptor, filter)) {
                                                        descriptors = extend(descriptors || {}, key, descriptor);
                                                    }
                                                }
                                            }
                                            return descriptors;
                                        },
                                        /**
                                         * Description goes here
                                         * @method addDescriptor
                                         * @param  {string}     name        - definition
                                         * @param  {Object}     descriptor  - definition
                                         */
                                        addDescriptor: function (name, descriptor) {
                                            _descriptors = extend(_descriptors || {}, name, descriptor);
                                            return this;
                                        },
                                        /**
                                         * Description goes here
                                         * @method matchDescriptor
                                         * @param  {Object}     descriptor  - definition
                                         * @param  {Object}     filter      - definition
                                         */
                                        matchDescriptor: function (descriptor, filter) {
                                            if (typeOf(descriptor) !== &#x27;object&#x27; || typeOf(filter) !== &#x27;object&#x27;) {
                                                return;
                                            }
                                            for (var key in filter) {
                                                var match = filter[key];
                                                if (match === undefined) {
                                                    if (!(key in descriptor)) {
                                                        return false;
                                                    }
                                                } else {
                                                    var value = descriptor[key];
                                                    if (match instanceof Array) {
                                                        if (!(value instanceof Array)) {
                                                            return false;
                                                        }
                                                        for (var i = 0; i &lt; match.length; ++i) {
                                                            if (value.indexOf(match[i]) &lt; 0) {
                                                                return false;
                                                            }
                                                        }
                                                    } else if (!(value === match || this.matchDescriptor(value, match))) {
                                                        return false;
                                                    }
                                                }
                                            }
                                            return true;
                                        },
                                        /**
                                         * Description goes here
                                         * @method linkBase
                                         * @param  {Method}     method      - definition
                                         * @return {Method}     method      - definition
                                         */
                                        linkBase: function (method) {
                                            if (!this[method]) {
                                                this.extend(method, function () {
                                                    var baseMethod = parent &amp;&amp; parent[method];
                                                    if (baseMethod) {
                                                        return baseMethod.apply(parent, arguments);
                                                    }
                                                });
                                            }
                                            return this;
                                        }        
                                    });
                                }
                            });
                        
                            /**
                             * Description goes here
                             * @class ClassMeta
                             * @constructor
                             * @extends MetaBase
                             */
                            var ClassMeta = MetaBase.extend({
                                constructor: function(baseClass, subClass, protocols, macros)  {
                                    var _isProtocol = (subClass === Protocol) || (subClass.prototype instanceof Protocol),
                                        _macros     = macros ? macros.slice(0) : undefined;
                                    this.base(baseClass.$meta, protocols);
                                    this.extend({
                                        getBase: function () { return baseClass; },
                                        getClass: function () { return subClass; },
                                        isProtocol: function () { return _isProtocol; },
                                        getAllProtocols: function () {
                                            var protocols = this.base();
                                            if (!_isProtocol &amp;&amp; baseClass.$meta) {
                                                var baseProtocols = baseClass.$meta.getAllProtocols();
                                                for (var i = 0; i &lt; baseProtocols.length; ++i) {
                                                    var protocol = baseProtocols[i];
                                                    if (protocols.indexOf(protocol) &lt; 0) {
                                                        protocols.push(protocol);
                                                    }
                                                }
                                            }
                                            return protocols;
                                        },
                                        protocolAdded: function (metadata, protocol) {
                                            this.base(metadata, protocol);
                                            if (!_macros || _macros.length == 0) {
                                                return;
                                            }
                                            for (var i = 0; i &lt; _macros.length; ++i) {
                                                macro = _macros[i];
                                                if ($isFunction(macro.protocolAdded)) {
                                                    macro.protocolAdded(metadata, protocol);
                                                }
                                            }
                                        },
                                        conformsTo: function (protocol) {
                                            if (!(protocol &amp;&amp; (protocol.prototype instanceof Protocol))) {
                                                return false;
                                            } else if ((protocol === subClass) || (subClass.prototype instanceof protocol)) {
                                                return true;
                                            }
                                            if (this.base(protocol)) {
                                                return true;
                                            }
                                            return baseClass &amp;&amp; (baseClass !== Protocol) &amp;&amp; baseClass.conformsTo
                                                 ? baseClass.conformsTo(protocol)
                                                 : false;
                                        },
                                        apply: function (step, metadata, target, definition) {
                                            this.base(step, metadata, target, definition);
                                            if (!_macros || _macros.length == 0) {
                                                return;
                                            }
                                            var inherit = (this !== metadata),
                                                active  = (step !== MetaStep.Subclass);
                                            for (var i = 0; i &lt; _macros.length; ++i) {
                                                var macro = _macros[i];
                                                if ((!active  || macro.isActive()) &amp;&amp;
                                                    (!inherit || macro.shouldInherit())) {
                                                    macro.apply(step, metadata, target, definition);
                                                }
                                            }
                                        }
                                    });
                                    this.addProtocol(protocols);
                                }
                            });
                        
                            /**
                             * Description goes here
                             * @class InstanceMeta
                             * @constructor
                             * @extends MetaBase
                             */
                            var InstanceMeta = MetaBase.extend({
                                constructor: function (classMeta) {
                                    this.base(classMeta);
                                    this.extend({
                                        getBase: function () { return classMeta.getBase(); },
                                        getClass: function () { return classMeta.getClass(); },
                                        isProtocol: function () { return classMeta.isProtocol(); }
                                    });
                                }
                            });
                        
                            var baseExtend  = Base.extend;
                            Base.extend = Abstract.extend = function () {
                                return (function (base, args) {
                                    var protocols, mixins, macros, 
                                        constraints = args;
                                    if (base.prototype instanceof Protocol) {
                                        (protocols = []).push(base);
                                    }
                                    if (args.length &gt; 0 &amp;&amp; (args[0] instanceof Array)) {
                                        constraints = args.shift();
                                    }
                                    while (constraints.length &gt; 0) {
                                        var constraint = constraints[0];
                                        if (!constraint) {
                                            break;
                                        } else if (constraint.prototype instanceof Protocol) {
                                            (protocols || (protocols = [])).push(constraint);
                                        } else if (constraint instanceof MetaMacro) {
                                            (macros || (macros = [])).push(constraint);
                                        } else if ($isFunction(constraint) 
                                                   &amp;&amp;  constraint.prototype instanceof MetaMacro) {
                                            (macros || (macros = [])).push(new constraint);
                                        } else if (constraint.prototype) {
                                            (mixins || (mixins = [])).push(constraint);
                                        } else {
                                            break;
                                        }
                                        constraints.shift();
                                    }
                                    var instanceDef = args.shift(),
                                        staticDef   = args.shift(),
                                        subclass    = baseExtend.call(base, instanceDef, staticDef),
                                        metadata    = new ClassMeta(base, subclass, protocols, macros);
                                    Object.defineProperty(subclass, META, {
                                        enumerable:   false,
                                        configurable: false,
                                        writable:     false,
                                        value:        metadata
                                    });
                                    Object.defineProperty(subclass.prototype, META, {
                                        enumerable:   false,
                                        configurable: false,
                                        get:          _createInstanceMeta
                                    });
                                    subclass.conformsTo = metadata.conformsTo.bind(metadata);
                                    metadata.apply(MetaStep.Subclass, metadata, subclass.prototype, instanceDef);
                                    if (mixins) {
                                        Array2.forEach(mixins, subclass.implement, subclass);
                                    }
                                    return subclass;
                                    })(this, Array.prototype.slice.call(arguments));
                            };
                        
                            function _createInstanceMeta() {
                                var spec = _createInstanceMeta.spec ||
                                    (_createInstanceMeta.spec = {
                                        enumerable:   false,
                                        configurable: false,
                                        writable:     false
                                    }),
                                    metadata = new InstanceMeta(this.constructor.$meta);
                                spec.value = metadata;
                                Object.defineProperty(this, META, spec);
                                delete spec.value;
                                return metadata;
                            }
                        
                            Base.prototype.conformsTo = function (protocol) {
                                return this.constructor.$meta.conformsTo(protocol);
                            };
                            
                            var implement = Base.implement;
                            Base.implement = Abstract.implement = function (source) {
                                if ($isFunction(source)) {
                                    source = source.prototype; 
                                }
                                var metadata = this.$meta;
                                implement.call(this, source);
                                if (metadata) {
                                    metadata.apply(MetaStep.Implement, metadata, this.prototype, source);
                                }
                                return this;
                            }
                        
                            var extendInstance = Base.prototype.extend;
                            Base.prototype.extend = function (key, value) {
                                var definition = (arguments.length === 1) ? key : {};
                                if (arguments.length &gt;= 2) {
                                    definition[key] = value;
                                }
                                var metadata = this.$meta;
                                extendInstance.call(this, definition);
                                if (metadata) {
                                    metadata.apply(MetaStep.Extend, metadata, this, definition);
                                }
                                return this;
                            }
                        
                            /**
                             * Metamacro to proxy protocol methods through delegate.
                             * @class $proxyProtocol
                             * @extends MetaMacro
                             */
                            var $proxyProtocol = MetaMacro.extend({
                                apply: function (step, metadata, target, definition) {
                                    var clazz = metadata.getClass();
                                    if (clazz === Protocol) {
                                        return;
                                    }    
                                    var protocolProto = Protocol.prototype;
                                    for (var key in definition) {
                                        if (key in protocolProto) {
                                            continue;
                                        }
                                        var member = target[key];
                                        if ($isFunction(member)) {
                                            (function (methodName) {
                                                target[methodName] = function () {
                                                    var args = Array.prototype.slice.call(arguments);
                                                    return this.__invoke(methodName, args);
                                                }
                                            })(key);
                                        }
                                    }
                                    if (step === MetaStep.Subclass) {
                                        clazz.adoptedBy = Protocol.adoptedBy;
                                    }
                                },
                                protocolAdded: function (metadata, protocol) {
                                    var source        = protocol.prototype,
                                        target        = metadata.getClass().prototype,
                                        protocolProto = Protocol.prototype;
                                    for (var key in source) {
                                        if (!((key in protocolProto) &amp;&amp; (key in this))) {
                                            var descriptor = _getPropertyDescriptor(source, key);
                                            Object.defineProperty(target, key, descriptor);
                                        }
                                    }
                                },
                                shouldInherit: True,
                                isActive: True
                            });
                            Protocol.extend     = Base.extend
                            Protocol.implement  = Base.implement;;
                            Protocol.$meta      = new ClassMeta(Base, Protocol, null, [new $proxyProtocol]);
                            Protocol.$meta.apply(MetaStep.Subclass, Protocol.$meta, Protocol.prototype);
                        
                            /**
                             * Description goes here
                             * @class StrictProtocol
                             * @constructor
                             * @extends Protocol     
                             */
                            var StrictProtocol = Protocol.extend({
                                constructor: function (proxy, strict) {
                                    this.base(proxy, (strict === undefined) || strict);
                                }
                            });
                        
                            /**
                             * Metamacro to create properties.
                             * @class $properties
                             * @constructor
                             * @extends MetaMacro
                             */
                            var $properties = MetaMacro.extend({
                                constructor: function _(tag) {
                                    var spec = _.spec || (_.spec = {});
                                    spec.value = tag || &#x27;$properties&#x27;;
                                    Object.defineProperty(this, &#x27;tag&#x27;, spec);
                                },
                                apply: function _(step, metadata, target, definition) {
                                    if ($isNothing(definition) || !definition.hasOwnProperty(this.tag)) {
                                        return;
                                    }
                                    var properties = definition[this.tag];
                                    if ($isFunction(properties)) {
                                        properties = properties();
                                    }
                                    for (var name in properties) {
                                        var property = properties[name],
                                            spec = _.spec || (_.spec = {
                                                configurable: true,
                                                enumerable:   true
                                            });
                                        if ($isNothing(property) || $isString(property) ||
                                            typeOf(property.length) == &quot;number&quot; || typeOf(property) !== &#x27;object&#x27;) {
                                            property = { value: property };
                                        }
                                        if (target instanceof Protocol) {
                                            spec.get = function (get) {
                                                return function () {
                                                    return this.__get(get);
                                                };
                                            }(name);
                                            spec.set = function (set) {
                                                return function (value) {
                                                    return this.__set(set, value);
                                                };
                                            }(name);
                                        } else {
                                            spec.writable = true;
                                            if (property.get || property.set) {
                                                var methods = {},
                                                    cname   = name.charAt(0).toUpperCase() + name.slice(1);
                                                if (property.get) {
                                                    var get      = &#x27;get&#x27; + cname; 
                                                    methods[get] = property.get;
                                                    spec.get     = _makeGetter(get);
                                                }
                                                if (property.set) {
                                                    var set      = &#x27;set&#x27; + cname 
                                                    methods[set] = property.set;
                                                    spec.set     = _makeSetter(set); 
                                                }
                                                if (step == MetaStep.Extend) {
                                                    target.extend(methods);
                                                } else {
                                                    metadata.getClass().implement(methods);
                                                }
                                                delete spec.writable;
                                            } else {
                                                spec.value = property.value;
                                            }
                                        }
                                        _cleanDescriptor(property);
                                        this.defineProperty(metadata, target, name, spec, property);
                                        _cleanDescriptor(spec);
                                    }
                                    delete definition[this.tag];
                                    delete target[this.tag];
                                },
                                defineProperty: function(metadata, target, name, spec, descriptor) {
                                    metadata.defineProperty(target, name, spec, descriptor);
                                },
                                shouldInherit: True,
                                isActive: True
                            });
                        
                            function _makeGetter(getMethodName) {
                                return function () {
                                    var getter = this[getMethodName];
                                    if ($isFunction(getter)) {
                                        return getter.call(this);
                                    }
                                };   
                            }
                        
                            function _makeSetter(setMethodName) {
                                return function (value) {
                                    var setter = this[setMethodName];
                                    if ($isFunction(setter)) {
                                        setter.call(this, value);
                                        return value;
                                    }
                                };
                            }
                        
                            function _cleanDescriptor(descriptor) {
                                delete descriptor.writable;
                                delete descriptor.value;
                                delete descriptor.get;
                                delete descriptor.set;
                            }
                        
                            /**
                             * Metamacro to derive properties from existng methods.
                             * @class $inferProperties
                             * @extends MetaMacro
                             */
                            var $inferProperties = MetaMacro.extend({
                                apply: function _(step, metadata, target, definition) {
                                    for (var key in definition) {
                                        var value = definition[key];
                                        if (!$isFunction(value)) {
                                            continue;
                                        }
                                        var spec = _.spec || (_.spec = {
                                            configurable: true,
                                            enumerable:   true
                                        });
                                        if (_inferProperty(key, value, definition, spec)) {
                                            var name = spec.name;
                                            if (name &amp;&amp; !(name in target)) {
                                                spec.get = _makeGetter(spec.get);
                                                spec.set = _makeSetter(spec.set);                        
                                                this.defineProperty(metadata, target, name, spec);
                                            }
                                            delete spec.name;
                                            delete spec.get;
                                            delete spec.set;
                                        }
                                    }
                                },
                                defineProperty: function(metadata, target, name, spec) {
                                    metadata.defineProperty(target, name, spec);
                                },
                                shouldInherit: True,
                                isActive: True
                            });
                        
                            var DEFAULT_GETTERS = [&#x27;get&#x27;, &#x27;is&#x27;];
                        
                            function _inferProperty(key, value, definition, spec) {
                                for (var i = 0; i &lt; DEFAULT_GETTERS.length; ++i) {
                                    var prefix = DEFAULT_GETTERS[i];
                                    if (key.lastIndexOf(prefix, 0) == 0) {
                                        if (value.length === 0) {  // no arguments
                                            var name  = key.substring(prefix.length);
                                            spec.get  = key;
                                            spec.set  = &#x27;set&#x27; + name;
                                            spec.name = name.charAt(0).toLowerCase() + name.slice(1);
                                            return true;
                                        }
                                    }
                                }
                                if (key.lastIndexOf(&#x27;set&#x27;, 0) == 0) {
                                    if (value.length === 1) {  // 1 argument
                                        var name  = key.substring(3);
                                        spec.set  = key;
                                        spec.get  = &#x27;get&#x27; + name;
                                        spec.name = name.charAt(0).toLowerCase() + name.slice(1);
                                        return true;
                                    }
                                }
                            }
                        
                            /**
                             * Metamacro to inherit static members in subclass.
                             * @class $inhertStatic
                             * @constructor
                             * @extends MetaMacro
                             */
                            var $inheritStatic = MetaMacro.extend({
                                constructor: function _(/*members*/) {
                                    var spec = _.spec || (_.spec = {});
                                    spec.value = Array.prototype.slice.call(arguments);
                                    Object.defineProperty(this, &#x27;members&#x27;, spec);
                                    delete spec.value;
                                },
                                apply: function (step, metadata, target) {
                                    if (step === MetaStep.Subclass) {
                                        var members  = this.members,
                                            clazz    = metadata.getClass(),
                                            ancestor = $ancestorOf(clazz);
                                        if (members.length &gt; 0) {
                                            for (var i = 0; i &lt; members.length; ++i) {
                                                var member = members[i];
                                                if (!(member in clazz)) {
                                                    clazz[member] = ancestor[member];
                                                }
                                            }
                                        } else if (ancestor !== Base &amp;&amp; ancestor !== Object) {
                                            for (var key in ancestor) {
                                                if (ancestor.hasOwnProperty(key) &amp;&amp; !(key in clazz)) {
                                                    clazz[key] = ancestor[key];
                                                }
                                            }
                                        }
                                    }
                                },
                                shouldInherit: True
                            });
                        
                            /**
                             * Base class to prefer coercion over casting.
                             * @class Miruken
                             * @extends Base
                             */
                            var Miruken = Base.extend(null, {
                                coerce: function () { return this.new.apply(this, arguments); }
                            });
                        
                            /**
                             * Protocol for Disposing
                             * @class Disposing
                             * @extends Protocol
                             */
                            var Disposing = Protocol.extend({
                                /**
                                 * Releases the object.
                                 * @method dispose
                                 */
                                dispose: function () {}
                            });
                        
                            /**
                             * Description goes here
                             * @class DisposingMixin
                             * @extends Module
                             */
                            var DisposingMixin = Module.extend({
                                dispose: function (object) {
                                    if ($isFunction(object._dispose)) {
                                        object._dispose();
                                        object.dispose = Undefined;  // dispose once
                                    }
                                }
                            });
                        
                            /**
                             * Description goes here
                             * @class Invoking
                             * @extends StrictProtocol
                             * @constructor
                             */
                            var Invoking = StrictProtocol.extend({
                                /**
                                 * Invokes the function with dependencies.
                                 * @param   {Function} fn           - function to invoke
                                 * @param   {Array}    dependencies - function dependencies
                                 * @param   {Object}   ctx          - function context
                                 * @return {Object} result of function.
                                 */
                                invoke: function (fn, dependencies, ctx) {}
                            });
                        
                            /**
                             * Description goes here
                             * @class Parenting
                             * @extends Protocol
                             */
                            var Parenting = Protocol.extend({
                                /**
                                 * Creates a new child of the parent.
                                 * @method newChild
                                 * @return {Any} the new child.
                                 */
                                newChild: function () {}
                            });
                        
                            /**
                             * Description goes here
                             * @class Starting
                             * @extends Protocol
                             */
                            var Starting = Protocol.extend({
                                start: function () {}
                            });
                        
                            /**
                             * Description goes here
                             * @class Startup
                             * @extends Base
                             */
                            var Startup = Base.extend(Starting, {
                                start: function () {}
                            });
                        
                            /**
                             * Convenience function for disposing resources.
                             * @method $using
                             * @param    {Disposing}           disposing  - object to dispose
                             * @param    {Function | Promise}  action     - block or Promise
                             * @param    {Object}              context    - block context
                             * @return   {Any} result of executing action in context.
                             */
                            function $using(disposing, action, context) {
                                if (disposing &amp;&amp; $isFunction(disposing.dispose)) {
                                    if ($isFunction(action)) {
                                        var result;
                                        try {
                                            result = action.call(context, disposing);
                                            return result;
                                        } finally {
                                            if ($isPromise(result)) {
                                                action = result;
                                            } else {
                                                disposing.dispose();
                                            }
                                        }
                                    } else if (!$isPromise(action)) {
                                        return;
                                    }
                                    action.finally(function () { disposing.dispose(); });
                                    return action;
                                }
                            }
                        
                            /**
                             * Description goes here
                             * @class Modifier
                             */
                            function Modifier() {}
                            Modifier.isModified = function (source) {
                                return source instanceof Modifier;
                            };
                            Modifier.unwrap = function (source) {
                                return (source instanceof Modifier) 
                                     ? Modifier.unwrap(source.getSource())
                                     : source;
                            }
                            function $createModifier() {
                                var allowNew;
                                function modifier(source) {
                                    if (this === global) {
                                        if (modifier.test(source)) {
                                            return source;
                                        }
                                        allowNew = true;
                                        var wrapped = new modifier(source);
                                        allowNew = false;
                                        return wrapped;
                                    } else {
                                        if (!allowNew) {
                                            throw new Error(&quot;Modifiers should not be called with the new operator.&quot;);
                                        }
                                        this.getSource = function () {
                                            return source;
                                        }
                                    }
                                }
                                modifier.prototype = new Modifier();
                                modifier.test      = function (source) {
                                    if (source instanceof modifier) {
                                        return true;
                                    } else if (source instanceof Modifier) {
                                        return modifier.test(source.getSource());
                                    }
                                    return false;
                                }
                                return modifier;
                            }
                        
                            /**
                             * Description goes here
                             * @class ArrayManager
                             * @extends Base
                             */
                            var ArrayManager = Base.extend({
                                constructor: function (items) {
                                    var _items = [];
                                    this.extend({
                                        /** 
                                         * Description goes here
                                         * @method getItems
                                         * @return {Object} item
                                         */
                                        getItems: function () { return _items; },
                                        /** 
                                         * Description goes here
                                         * @method getIndex
                                         * @return {Object} item
                                         */
                                        getIndex: function (index) {
                                            if (_items.length &gt; index) {
                                                return _items[index];
                                            }
                                        },
                                        /** 
                                         * Description goes here
                                         * @method getIndex
                                         * @param  {Index}      index - description
                                         * @param  {Item}       item  - description
                                         * @return {Object}     item
                                         */
                                        setIndex: function (index, item) {
                                            if ((_items.length &lt;= index) ||
                                                (_items[index] === undefined)) {
                                                _items[index] = this.mapItem(item);
                                            }
                                            return this;
                                        },
                                        /** 
                                         * Description goes here
                                         * @method insertIndex
                                         * @param  {Index}      index - description
                                         * @param  {Item}       item  - description
                                         * @return {Object}     item
                                         */
                                        insertIndex: function (index, item) {
                                            _items.splice(index, 0, this.mapItem(item));
                                            return this;
                                        },
                                        /** 
                                         * Description goes here
                                         * @method replaceIndex
                                         * @param  {Index}      index - description
                                         * @param  {Item}       item  - description
                                         * @return {Object}     item
                                         */
                                        replaceIndex: function (index, item) {
                                            _items[index] = this.mapItem(item);
                                            return this;
                                        },
                                        /** 
                                         * Description goes here
                                         * @method removeIndex
                                         * @param  {Index}      index - description
                                         * @return {Object}     item
                                         */
                                        removeIndex: function (index) {
                                            if (_items.length &gt; index) {
                                                _items.splice(index, 1);
                                            }
                                            return this;
                                        },
                                        /** 
                                         * Description goes here
                                         * @method append
                                         * @param  {Items}      items - description
                                         * @return {Object}     this  - description
                                         */
                                        append: function (/* items */) {
                                            var newItems;
                                            if (arguments.length === 1 &amp;&amp; (arguments[0] instanceof Array)) {
                                                newItems = arguments[0];
                                            } else if (arguments.length &gt; 0) {
                                                newItems = arguments;
                                            }
                                            if (newItems) {
                                                for (var i = 0; i &lt; newItems.length; ++i) {
                                                    _items.push(this.mapItem(newItems[i]));
                                                }
                                            }
                                            return this;
                                        },
                                        /** 
                                         * Description goes here
                                         * @method merge
                                         * @param  {Array}      items - description
                                         * @return {This}       this  - description
                                         */
                                        merge: function (items) {
                                            for (var index = 0; index &lt; items.length; ++index) {
                                                var item = items[index];
                                                if (item !== undefined) {
                                                    this.setIndex(index, item);
                                                }
                                            }
                                            return this;
                                        }
                                    });
                                    if (items) {
                                        this.append(items);
                                    }
                                },
                                /** 
                                 * Description goes here
                                 * @method mapItem
                                 * @param  {Object}     item - description
                                 * @return {Object}     item - description
                                 */
                                mapItem: function (item) { return item; }
                            });
                        
                            /**
                             * Maintains a simple doublely-linked list with indexing.
                             * Indexes are partially ordered according to the order comparator.
                             * @class IndexedList
                             * @constructor
                             * @extends Base
                             */
                            var IndexedList = Base.extend({
                                constructor: function(order) {
                                    var _index = {};
                                    this.extend({
                                        /** 
                                         * Description goes here
                                         * @method isEmpty
                                         * @return {Object}     this - description
                                         */
                                        isEmpty: function () {
                                            return !this.head;
                                        },
                                        /** 
                                         * Description goes here
                                         * @method getIndex
                                         * @param  {Index}      index - description
                                         * @return {Index}      index - description
                                         */
                                        getIndex: function (index) {
                                            return index &amp;&amp; _index[index];
                                        },
                                        /** 
                                         * Description goes here
                                         * @method insert
                                         * @param  {Node}       node    - description
                                         * @param  {Index}      index   - description
                                         */
                                        insert: function (node, index) {
                                            var indexedNode = this.getIndex(index),
                                                insert      = indexedNode;
                                            if (index) {
                                                insert = insert || this.head;
                                                while (insert &amp;&amp; order(node, insert) &gt;= 0) {
                                                    insert = insert.next;
                                                }
                                            }
                                            if (insert) {
                                                var prev    = insert.prev;
                                                node.next   = insert;
                                                node.prev   = prev;
                                                insert.prev = node;
                                                if (prev) {
                                                    prev.next = node;
                                                }
                                                if (this.head === insert) {
                                                    this.head = node;
                                                }
                                            } else {
                                                delete node.next;
                                                var tail = this.tail;
                                                if (tail) {
                                                    node.prev = tail;
                                                    tail.next = node;
                                                } else {
                                                    this.head = node;
                                                    delete node.prev;
                                                }
                                                this.tail = node;
                                            }
                                            if (index) {
                                                node.index = index;
                                                if (!indexedNode) {
                                                    _index[index] = node;
                                                }
                                            }
                                        },
                                        /** 
                                         * Description goes here
                                         * @method remove
                                         * @param  {Node}       node    - description
                                         */
                                        remove: function (node) {
                                            var prev = node.prev,
                                                next = node.next;
                                            if (prev) {
                                                if (next) {
                                                    prev.next = next;
                                                    next.prev = prev;
                                                } else {
                                                    this.tail = prev;
                                                    delete prev.next;
                                                }
                                            } else if (next) {
                                                this.head = next;
                                                delete next.prev;
                                            } else {
                                                delete this.head;
                                                delete this.tail;
                                            }
                                            var index = node.index;
                                            if (this.getIndex(index) === node) {
                                                if (next &amp;&amp; next.index === index) {
                                                    _index[index] = next;
                                                } else {
                                                    delete _index[index];
                                                }
                                            }
                                        }
                                    });
                                }
                            });
                        
                            /**
                             * Facet enum
                             * @property Facet
                             * @type Enum
                             */
                            var Facet = Enum({
                                Parameters:           &#x27;parameters&#x27;,
                                Interceptors:         &#x27;interceptors&#x27;,
                                InterceptorSelectors: &#x27;interceptorSelectors&#x27;,
                                Delegate:             &#x27;delegate&#x27;
                                });
                        
                        
                            /**
                             * Description goes here
                             * @class Interceptor
                             * @extends Base
                             */
                            var Interceptor = Base.extend({
                                /**
                                 * @method intercept
                                 * @param  {Invocation} invocation
                                 * @return {Invocation} invocation
                                 */
                                intercept: function (invocation) {
                                    return invocation.proceed();
                                }
                            });
                        
                            /**
                             * Description goes here
                             * @class InterceptorSelector
                             * @extends Base
                             */
                            var InterceptorSelector = Base.extend({
                                /**
                                 * Description goes here
                                 * @method selectInterceptors
                                 * @param  {Type}           type
                                 * @param  {Method}         method
                                 * @param  {Interceptors}   interceptors
                                 * @return {Interceptors}   interceptors
                                 */
                                selectInterceptors: function (type, method, interceptors) {
                                    return interceptors;
                                }
                            });
                        
                            /**
                             * Description goes here
                             * @class ProxyBuilder
                             * @extends Base
                             */
                            var ProxyBuilder = Base.extend({
                                /**
                                 * Description goes here
                                 * @method buildProxy
                                 * @param  {Array}          types           - description
                                 * @param  {Options}        options         - description
                                 * @return {Object}         buildProxy      - description
                                 */
                                buildProxy: function(types, options) {
                                    if (!(types instanceof Array)) {
                                        throw new TypeError(&quot;ProxyBuilder requires an array of types to proxy.&quot;);
                                    }
                                    var classes   = Array2.filter(types, $isClass),
                                        protocols = Array2.filter(types, $isProtocol);
                                    return _buildProxy(classes, protocols, options || {});
                                }
                            });
                        
                            function _buildProxy(classes, protocols, options) {
                                var base  = options.baseType || classes.shift() || Base,
                                    proxy = base.extend(protocols.concat(classes), {
                                    constructor: function _(facets) {
                                        var spec = _.spec || (_.spec = {});
                                        spec.value = facets[Facet.InterceptorSelectors]
                                        if (spec.value &amp;&amp; spec.value.length &gt; 0) {
                                            Object.defineProperty(this, &#x27;selectors&#x27;, spec);
                                        }
                                        spec.value = facets[Facet.Interceptors];
                                        if (spec.value &amp;&amp; spec.value.length &gt; 0) {
                                            Object.defineProperty(this, &#x27;interceptors&#x27;, spec);
                                        }
                                        spec.value = facets[Facet.Delegate];
                                        if (spec.value) {
                                            spec.writable = true;
                                            Object.defineProperty(this, &#x27;delegate&#x27;, spec);
                                        }
                                        ctor = _proxyMethod(&#x27;constructor&#x27;, this.base, base);
                                        ctor.apply(this, facets[Facet.Parameters]);
                                        delete spec.writable;
                                        delete spec.value;
                                    },
                                    getInterceptors: function (source, method) {
                                        var selectors = this.selectors;
                                        return selectors 
                                             ? Array2.reduce(selectors, function (interceptors, selector) {
                                                   return selector.selectInterceptors(source, method, interceptors);
                                               }, this.interceptors)
                                             : this.interceptors;
                                    },
                                    extend: _extendProxy
                                }, {
                                    shouldProxy: options.shouldProxy
                                });
                                _proxyClass(proxy, protocols);
                                proxy.extend = proxy.implement = _throwProxiesSealedExeception;
                                return proxy;
                            }
                        
                            function _throwProxiesSealedExeception()
                            {
                                throw new TypeError(&quot;Proxy classes are sealed and cannot be extended from.&quot;);
                            }
                        
                            /**
                             * Metamacro to intercept proxied methods.
                             * @class $interceptMethods
                             * @extends MetaMacro
                             */
                            var $interceptMethods = MetaMacro.extend({
                                apply: function (step, metadata, target, definition) {
                                    var proxy = metadata.getClass();
                                    switch (step) {
                                        case MetaStep.Subclass:
                                        {
                                            for (key in target) {
                                                if (!(key in _noProxyMethods) &amp;&amp;
                                                    (!proxy.shouldProxy || proxy.shouldProxy(key, proxy))) {
                                                    var descriptor = _getPropertyDescriptor(sourceProto, key);
                                                    if (&#x27;value&#x27; in descriptor) {
                                                        var member = descriptor.value;
                                                        if ($isNothing(member) || $isFunction(member)) {
                                                            target[key] = _proxyMethod(key, member, proxy);
                                                        }
                                                    }
                                                }
                                            }
                                            break;
                                        }
                                        case MetaStep.Implement:
                                        {
                                            break;
                                        }
                                        case MetaStep.Extend:
                                        {
                                            break;
                                        }
                                    }
                                },
                                protocolAdded: function (metadata, protocol) {
                                },
                                shouldInherit: True,
                                isActive: True
                            });
                        
                            function _proxyClass(proxy, protocols) {
                                var sources    = [proxy].concat(protocols),
                                    proxyProto = proxy.prototype,
                                    proxied    = {};
                                for (var i = 0; i &lt; sources.length; ++i) {
                                    var source      = sources[i],
                                        sourceProto = source.prototype,
                                        isProtocol  = $isProtocol(source);
                                    for (key in sourceProto) {
                                        if (!((key in proxied) || (key in _noProxyMethods))
                                        &amp;&amp; (!proxy.shouldProxy || proxy.shouldProxy(key, source))) {
                                            var descriptor = _getPropertyDescriptor(sourceProto, key);
                                            if (&#x27;value&#x27; in descriptor) {
                                                var member = isProtocol ? undefined : descriptor.value;
                                                if ($isNothing(member) || $isFunction(member)) {
                                                    proxyProto[key] = _proxyMethod(key, member, proxy);
                                                }
                                                proxied[key] = true;
                                            } else if (isProtocol) {
                                                var cname = key.charAt(0).toUpperCase() + key.slice(1),
                                                    get   = &#x27;get&#x27; + cname,
                                                    set   = &#x27;set&#x27; + cname,
                                                    spec  = _proxyClass.spec || (_proxyClass.spec = {
                                                        enumerable: true
                                                    });
                                                spec.get = function (get) {
                                                    var proxyGet;
                                                    return function () {
                                                        if (get in this) {
                                                            return (this[get]).call(this);
                                                        }
                                                        if (!proxyGet) {
                                                            proxyGet = _proxyMethod(get, undefined, proxy);
                                                        }
                                                        return proxyGet.call(this);
                                                    }
                                                }(get);
                                                spec.set = function (set) {
                                                    var proxySet;
                                                    return function (value) {
                                                        if (set in this) {
                                                            return (this[set]).call(this, value);
                                                        }
                                                        if (!proxySet) {
                                                            proxySet = _proxyMethod(set, undefined, proxy);
                                                        }
                                                        return proxySet.call(this, value);
                                                    }
                                                }(set);
                                                Object.defineProperty(proxy.prototype, key, spec);
                                                proxied[key] = true;
                                            }
                                        }
                                    }
                                }
                            }
                            
                            function _proxyMethod(key, method, source) {
                                var spec = _proxyMethod.spec || (_proxyMethod.spec = {}),
                                    interceptors;
                                function methodProxy() {
                                    var _this    = this,
                                        delegate = this.delegate,
                                        idx      = -1;
                                    if (!interceptors) {
                                        interceptors = this.getInterceptors(source, key);
                                    }
                                    var invocation = {
                                        args: Array.prototype.slice.call(arguments),
                                        useDelegate: function (value) {
                                            delegate = value; 
                                        },
                                        replaceDelegate: function (value) {
                                            _this.delegate = delegate = value;
                                        },
                                        proceed: function () {
                                            ++idx;
                                            if (interceptors &amp;&amp; idx &lt; interceptors.length) {
                                                var interceptor = interceptors[idx];
                                                return interceptor.intercept(invocation);
                                            }
                                            if (delegate) {
                                                var delegateMethod = delegate[key];
                                                if ($isFunction(delegateMethod)) {
                                                    return delegateMethod.apply(delegate, this.args);
                                                }
                                            } else if (method) {
                                                return method.apply(_this, this.args);
                                            }
                                            throw new Error(format(
                                                &quot;Interceptor cannot proceed without a class or delegate method &#x27;%1&#x27;.&quot;, key));
                                        }
                                    };
                                    spec.value = key;
                                    Object.defineProperty(invocation, &#x27;method&#x27;, spec);
                                    spec.value = source;
                                    Object.defineProperty(invocation, &#x27;source&#x27;, spec);
                                    delete spec.value;
                                    spec.get = function () {
                                        if (interceptors &amp;&amp; (idx + 1 &lt; interceptors.length)) {
                                            return true;
                                        }
                                        if (delegate) {
                                            return $isFunction(delegate(key));
                                        }
                                        return !!method;
                                    };
                                    Object.defineProperty(invocation, &#x27;canProceed&#x27;, spec);
                                    delete spec.get;
                                    return invocation.proceed();
                                }
                                methodProxy.baseMethod = method;
                                return methodProxy;
                            }
                            
                            function _extendProxy() {
                                var proxy     = this.constructor,
                                    clazz     = proxy.prototype,
                                    overrides = (arguments.length === 1) ? arguments[0] : {};
                                if (arguments.length &gt;= 2) {
                                    overrides[arguments[0]] = arguments[1];
                                }
                                for (methodName in overrides) {
                                    if (!(methodName in _noProxyMethods) &amp;&amp; 
                                        (!proxy.shouldProxy || proxy.shouldProxy(methodName, clazz))) {
                                        var method = this[methodName];
                                        if (method &amp;&amp; method.baseMethod) {
                                            this[methodName] = method.baseMethod;
                                        }
                                        this.base(methodName, overrides[methodName]);
                                        this[methodName] = _proxyMethod(methodName, this[methodName], clazz);
                                    }
                                }
                                return this;
                            }
                        
                            var _noProxyMethods = {
                                base: true, extend: true, constructor: true, conformsTo: true,
                                getInterceptors: true, getDelegate: true, setDelegate: true
                            };
                        
                            /**
                             * Package extensions
                             */
                            Package.implement({
                                export: function (name, member) {
                                    this.addName(name, member);
                                },
                                getProtocols: function (cb) {
                                    _listContents(this, cb, $isProtocol);
                                },
                                getClasses: function (cb) {
                                    _listContents(this, cb, function (member, memberName) {
                                        return $isClass(member) &amp;&amp; (memberName != &quot;constructor&quot;);
                                    });
                                },
                                getPackages: function (cb) {
                                    _listContents(this, cb, function (member, memberName) {
                                        return (member instanceof Package) &amp;&amp; (memberName != &quot;parent&quot;);
                                    });
                                }
                            });
                        
                            function _listContents(package, cb, filter) {
                                if ($isFunction(cb)) {
                                    for (memberName in package) {
                                        var member = package[memberName];
                                        if (!filter || filter(member, memberName)) {
                                            cb({ member: member, name: memberName});
                                        }
                                    }
                                }
                            }
                        
                            /**
                             * Description goes here
                             * @method $isProtocol
                             * @param    {Any}     protocol  - protocol to test
                             * @returns  {boolean} true if a protocol.
                             */
                            var $isProtocol = Protocol.isProtocol;
                        
                            /**
                             * Description goes here
                             * @method $isClass
                             * @param    {Any}     clazz  - class to test
                             * @returns  {boolean} true if a class (and not a protocol).
                             */
                            function $isClass(clazz) {
                                return clazz &amp;&amp; (clazz.prototype instanceof Base) &amp;&amp; !$isProtocol(clazz);
                            }
                        
                            /**
                             * Description goes here
                             * @method $classOf
                             * @param    {Object}  instance  - object
                             * @return   {Function} class of instance. 
                             */
                            function $classOf(instance) {
                                return instance &amp;&amp; instance.constructor;
                            }
                        
                            /**
                             * Description goes here
                             * @method $ancestorOf
                             * @param    {Function} clazz  - clazz
                             * @return   {Function} ancestor of class. 
                             */
                            function $ancestorOf(clazz) {
                                return clazz &amp;&amp; clazz.ancestor;
                            }
                        
                            /**
                             * Description goes here
                             * @method $isString
                             * @param    {Any}     str  - string to test
                             * @returns  {boolean} true if a string.
                             */
                            function $isString(str) {
                                return typeOf(str)  === &#x27;string&#x27;;
                            }
                        
                            /**
                             * Description goes here
                             * @method $isFunction
                             * @param    {Any}     fn  - function to test
                             * @returns  {boolean} true if a function.
                             */
                            function $isFunction(fn) {
                                return fn instanceof Function;
                            }
                        
                            /**
                             * Description goes here
                             * @method $isObject
                             * @param    {Any}     obj  - object to test
                             * @returns  {boolean} true if an object.
                             */
                            function $isObject(obj) {
                                return obj === Object(obj);
                            }
                        
                            /**
                             * Description goes here
                             * @method $isPromise
                             * @param    {Any}     promise  - promise to test
                             * @returns  {boolean} true if a promise. 
                             */
                            function $isPromise(promise) {
                                return promise &amp;&amp; $isFunction(promise.then);
                            }
                        
                            /**
                             * Description goes here
                             * @method $isNothing
                             * @param    {Any}     value  - value to test
                             * @returns  {boolean} true if value null or undefined.
                             */
                            function $isNothing(value) {
                                return (value === undefined || value === null);
                            }
                        
                            /**
                             * Description goes here
                             * @method $isSomething
                             * @param    {Any}     value  - value to test
                             * @returns  {boolean} true if value not null or undefined.
                             */
                            function $isSomething(value) {
                                return !$isNothing(value);
                            }
                        
                            /**
                             * Description goes here
                             * @method $lift
                             * @param    {Any}      value  - any value
                             * @return   {Function} function that returns value.
                             */
                            function $lift(value) {
                                return function() { return value; };
                            }
                        
                            /**
                             * Description goes here
                             * @method $lift
                             * @param    {Function} func                - function to throttle
                             * @param    {int}      wait                - time (ms) to throttle func
                             * @param    {boolean}  immediate           - if true, trigger func early
                             * @param    {Any}      defaultReturnValue  - value to return when throttled
                             * @return   {Function} throttled function 
                             */
                            function $debounce(func, wait, immediate, defaultReturnValue) {
                                var timeout;
                                return function () {
                                    var context = this, args = arguments;
                                    var later = function () {
                                        timeout = null;
                                        if (!immediate) {
                                            return func.apply(context, args);
                                        }
                                    };
                                    var callNow = immediate &amp;&amp; !timeout;
                                    clearTimeout(timeout);
                                    timeout = setTimeout(later, wait);
                                    if (callNow) {
                                        return func.apply(context, args);
                                    }
                                    return defaultReturnValue;
                                };
                            };
                            
                            function _getPropertyDescriptor(object, key) {
                                var source = object, descriptor;
                                while (source &amp;&amp; !(
                                    descriptor = Object.getOwnPropertyDescriptor(source, key))
                                      ) source = Object.getPrototypeOf(source);
                                return descriptor;
                            }
                        
                            /**
                             * Description goes here
                             * @method new
                             */
                            if (Function.prototype.new === undefined)
                                Function.prototype.new = function () {
                                    var args        = arguments,
                                        constructor = this;
                                    function Wrapper () { constructor.apply(this, args); }
                                    Wrapper.prototype  = constructor.prototype;
                                    return new Wrapper;
                                };
                        
                            if (typeof module !== &#x27;undefined&#x27; &amp;&amp; module.exports) {
                                module.exports = exports = miruken;
                            }
                        
                            /**
                             * Add miruken and Miruken to the global namespace
                             */
                            global.miruken = miruken;
                            global.Miruken = Miruken;
                        
                            eval(this.exports);
                        
                        }
                        
                            </pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/jquery/jquery-1.8.2.min.js"></script>
<script src="../assets/vendor/bootstrap/js/bootstrap.js"></script>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script src="../assets/js/yuidoc-bootstrap.js"></script>
<script>prettyPrint();</script>
</body>
</html>
